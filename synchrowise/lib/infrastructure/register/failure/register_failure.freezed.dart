// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'register_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$RegisterFailureTearOff {
  const _$RegisterFailureTearOff();

  _ConnectionFailure connection() {
    return const _ConnectionFailure();
  }

  _UnknownFailure unknown() {
    return const _UnknownFailure();
  }

  _ImagePickFailedFailure imagePickFailed() {
    return const _ImagePickFailedFailure();
  }

  _ImageCropperFailedFailure imageCropperFailed() {
    return const _ImageCropperFailedFailure();
  }

  _ImageTooLargeFailure imageTooLarge() {
    return const _ImageTooLargeFailure();
  }
}

/// @nodoc
const $RegisterFailure = _$RegisterFailureTearOff();

/// @nodoc
mixin _$RegisterFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connection,
    required TResult Function() unknown,
    required TResult Function() imagePickFailed,
    required TResult Function() imageCropperFailed,
    required TResult Function() imageTooLarge,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connection,
    TResult Function()? unknown,
    TResult Function()? imagePickFailed,
    TResult Function()? imageCropperFailed,
    TResult Function()? imageTooLarge,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connection,
    TResult Function()? unknown,
    TResult Function()? imagePickFailed,
    TResult Function()? imageCropperFailed,
    TResult Function()? imageTooLarge,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ConnectionFailure value) connection,
    required TResult Function(_UnknownFailure value) unknown,
    required TResult Function(_ImagePickFailedFailure value) imagePickFailed,
    required TResult Function(_ImageCropperFailedFailure value)
        imageCropperFailed,
    required TResult Function(_ImageTooLargeFailure value) imageTooLarge,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ConnectionFailure value)? connection,
    TResult Function(_UnknownFailure value)? unknown,
    TResult Function(_ImagePickFailedFailure value)? imagePickFailed,
    TResult Function(_ImageCropperFailedFailure value)? imageCropperFailed,
    TResult Function(_ImageTooLargeFailure value)? imageTooLarge,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ConnectionFailure value)? connection,
    TResult Function(_UnknownFailure value)? unknown,
    TResult Function(_ImagePickFailedFailure value)? imagePickFailed,
    TResult Function(_ImageCropperFailedFailure value)? imageCropperFailed,
    TResult Function(_ImageTooLargeFailure value)? imageTooLarge,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RegisterFailureCopyWith<$Res> {
  factory $RegisterFailureCopyWith(
          RegisterFailure value, $Res Function(RegisterFailure) then) =
      _$RegisterFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$RegisterFailureCopyWithImpl<$Res>
    implements $RegisterFailureCopyWith<$Res> {
  _$RegisterFailureCopyWithImpl(this._value, this._then);

  final RegisterFailure _value;
  // ignore: unused_field
  final $Res Function(RegisterFailure) _then;
}

/// @nodoc
abstract class _$ConnectionFailureCopyWith<$Res> {
  factory _$ConnectionFailureCopyWith(
          _ConnectionFailure value, $Res Function(_ConnectionFailure) then) =
      __$ConnectionFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$ConnectionFailureCopyWithImpl<$Res>
    extends _$RegisterFailureCopyWithImpl<$Res>
    implements _$ConnectionFailureCopyWith<$Res> {
  __$ConnectionFailureCopyWithImpl(
      _ConnectionFailure _value, $Res Function(_ConnectionFailure) _then)
      : super(_value, (v) => _then(v as _ConnectionFailure));

  @override
  _ConnectionFailure get _value => super._value as _ConnectionFailure;
}

/// @nodoc

class _$_ConnectionFailure implements _ConnectionFailure {
  const _$_ConnectionFailure();

  @override
  String toString() {
    return 'RegisterFailure.connection()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ConnectionFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connection,
    required TResult Function() unknown,
    required TResult Function() imagePickFailed,
    required TResult Function() imageCropperFailed,
    required TResult Function() imageTooLarge,
  }) {
    return connection();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connection,
    TResult Function()? unknown,
    TResult Function()? imagePickFailed,
    TResult Function()? imageCropperFailed,
    TResult Function()? imageTooLarge,
  }) {
    return connection?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connection,
    TResult Function()? unknown,
    TResult Function()? imagePickFailed,
    TResult Function()? imageCropperFailed,
    TResult Function()? imageTooLarge,
    required TResult orElse(),
  }) {
    if (connection != null) {
      return connection();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ConnectionFailure value) connection,
    required TResult Function(_UnknownFailure value) unknown,
    required TResult Function(_ImagePickFailedFailure value) imagePickFailed,
    required TResult Function(_ImageCropperFailedFailure value)
        imageCropperFailed,
    required TResult Function(_ImageTooLargeFailure value) imageTooLarge,
  }) {
    return connection(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ConnectionFailure value)? connection,
    TResult Function(_UnknownFailure value)? unknown,
    TResult Function(_ImagePickFailedFailure value)? imagePickFailed,
    TResult Function(_ImageCropperFailedFailure value)? imageCropperFailed,
    TResult Function(_ImageTooLargeFailure value)? imageTooLarge,
  }) {
    return connection?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ConnectionFailure value)? connection,
    TResult Function(_UnknownFailure value)? unknown,
    TResult Function(_ImagePickFailedFailure value)? imagePickFailed,
    TResult Function(_ImageCropperFailedFailure value)? imageCropperFailed,
    TResult Function(_ImageTooLargeFailure value)? imageTooLarge,
    required TResult orElse(),
  }) {
    if (connection != null) {
      return connection(this);
    }
    return orElse();
  }
}

abstract class _ConnectionFailure implements RegisterFailure {
  const factory _ConnectionFailure() = _$_ConnectionFailure;
}

/// @nodoc
abstract class _$UnknownFailureCopyWith<$Res> {
  factory _$UnknownFailureCopyWith(
          _UnknownFailure value, $Res Function(_UnknownFailure) then) =
      __$UnknownFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$UnknownFailureCopyWithImpl<$Res>
    extends _$RegisterFailureCopyWithImpl<$Res>
    implements _$UnknownFailureCopyWith<$Res> {
  __$UnknownFailureCopyWithImpl(
      _UnknownFailure _value, $Res Function(_UnknownFailure) _then)
      : super(_value, (v) => _then(v as _UnknownFailure));

  @override
  _UnknownFailure get _value => super._value as _UnknownFailure;
}

/// @nodoc

class _$_UnknownFailure implements _UnknownFailure {
  const _$_UnknownFailure();

  @override
  String toString() {
    return 'RegisterFailure.unknown()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _UnknownFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connection,
    required TResult Function() unknown,
    required TResult Function() imagePickFailed,
    required TResult Function() imageCropperFailed,
    required TResult Function() imageTooLarge,
  }) {
    return unknown();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connection,
    TResult Function()? unknown,
    TResult Function()? imagePickFailed,
    TResult Function()? imageCropperFailed,
    TResult Function()? imageTooLarge,
  }) {
    return unknown?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connection,
    TResult Function()? unknown,
    TResult Function()? imagePickFailed,
    TResult Function()? imageCropperFailed,
    TResult Function()? imageTooLarge,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ConnectionFailure value) connection,
    required TResult Function(_UnknownFailure value) unknown,
    required TResult Function(_ImagePickFailedFailure value) imagePickFailed,
    required TResult Function(_ImageCropperFailedFailure value)
        imageCropperFailed,
    required TResult Function(_ImageTooLargeFailure value) imageTooLarge,
  }) {
    return unknown(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ConnectionFailure value)? connection,
    TResult Function(_UnknownFailure value)? unknown,
    TResult Function(_ImagePickFailedFailure value)? imagePickFailed,
    TResult Function(_ImageCropperFailedFailure value)? imageCropperFailed,
    TResult Function(_ImageTooLargeFailure value)? imageTooLarge,
  }) {
    return unknown?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ConnectionFailure value)? connection,
    TResult Function(_UnknownFailure value)? unknown,
    TResult Function(_ImagePickFailedFailure value)? imagePickFailed,
    TResult Function(_ImageCropperFailedFailure value)? imageCropperFailed,
    TResult Function(_ImageTooLargeFailure value)? imageTooLarge,
    required TResult orElse(),
  }) {
    if (unknown != null) {
      return unknown(this);
    }
    return orElse();
  }
}

abstract class _UnknownFailure implements RegisterFailure {
  const factory _UnknownFailure() = _$_UnknownFailure;
}

/// @nodoc
abstract class _$ImagePickFailedFailureCopyWith<$Res> {
  factory _$ImagePickFailedFailureCopyWith(_ImagePickFailedFailure value,
          $Res Function(_ImagePickFailedFailure) then) =
      __$ImagePickFailedFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$ImagePickFailedFailureCopyWithImpl<$Res>
    extends _$RegisterFailureCopyWithImpl<$Res>
    implements _$ImagePickFailedFailureCopyWith<$Res> {
  __$ImagePickFailedFailureCopyWithImpl(_ImagePickFailedFailure _value,
      $Res Function(_ImagePickFailedFailure) _then)
      : super(_value, (v) => _then(v as _ImagePickFailedFailure));

  @override
  _ImagePickFailedFailure get _value => super._value as _ImagePickFailedFailure;
}

/// @nodoc

class _$_ImagePickFailedFailure implements _ImagePickFailedFailure {
  const _$_ImagePickFailedFailure();

  @override
  String toString() {
    return 'RegisterFailure.imagePickFailed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ImagePickFailedFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connection,
    required TResult Function() unknown,
    required TResult Function() imagePickFailed,
    required TResult Function() imageCropperFailed,
    required TResult Function() imageTooLarge,
  }) {
    return imagePickFailed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connection,
    TResult Function()? unknown,
    TResult Function()? imagePickFailed,
    TResult Function()? imageCropperFailed,
    TResult Function()? imageTooLarge,
  }) {
    return imagePickFailed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connection,
    TResult Function()? unknown,
    TResult Function()? imagePickFailed,
    TResult Function()? imageCropperFailed,
    TResult Function()? imageTooLarge,
    required TResult orElse(),
  }) {
    if (imagePickFailed != null) {
      return imagePickFailed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ConnectionFailure value) connection,
    required TResult Function(_UnknownFailure value) unknown,
    required TResult Function(_ImagePickFailedFailure value) imagePickFailed,
    required TResult Function(_ImageCropperFailedFailure value)
        imageCropperFailed,
    required TResult Function(_ImageTooLargeFailure value) imageTooLarge,
  }) {
    return imagePickFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ConnectionFailure value)? connection,
    TResult Function(_UnknownFailure value)? unknown,
    TResult Function(_ImagePickFailedFailure value)? imagePickFailed,
    TResult Function(_ImageCropperFailedFailure value)? imageCropperFailed,
    TResult Function(_ImageTooLargeFailure value)? imageTooLarge,
  }) {
    return imagePickFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ConnectionFailure value)? connection,
    TResult Function(_UnknownFailure value)? unknown,
    TResult Function(_ImagePickFailedFailure value)? imagePickFailed,
    TResult Function(_ImageCropperFailedFailure value)? imageCropperFailed,
    TResult Function(_ImageTooLargeFailure value)? imageTooLarge,
    required TResult orElse(),
  }) {
    if (imagePickFailed != null) {
      return imagePickFailed(this);
    }
    return orElse();
  }
}

abstract class _ImagePickFailedFailure implements RegisterFailure {
  const factory _ImagePickFailedFailure() = _$_ImagePickFailedFailure;
}

/// @nodoc
abstract class _$ImageCropperFailedFailureCopyWith<$Res> {
  factory _$ImageCropperFailedFailureCopyWith(_ImageCropperFailedFailure value,
          $Res Function(_ImageCropperFailedFailure) then) =
      __$ImageCropperFailedFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$ImageCropperFailedFailureCopyWithImpl<$Res>
    extends _$RegisterFailureCopyWithImpl<$Res>
    implements _$ImageCropperFailedFailureCopyWith<$Res> {
  __$ImageCropperFailedFailureCopyWithImpl(_ImageCropperFailedFailure _value,
      $Res Function(_ImageCropperFailedFailure) _then)
      : super(_value, (v) => _then(v as _ImageCropperFailedFailure));

  @override
  _ImageCropperFailedFailure get _value =>
      super._value as _ImageCropperFailedFailure;
}

/// @nodoc

class _$_ImageCropperFailedFailure implements _ImageCropperFailedFailure {
  const _$_ImageCropperFailedFailure();

  @override
  String toString() {
    return 'RegisterFailure.imageCropperFailed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ImageCropperFailedFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connection,
    required TResult Function() unknown,
    required TResult Function() imagePickFailed,
    required TResult Function() imageCropperFailed,
    required TResult Function() imageTooLarge,
  }) {
    return imageCropperFailed();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connection,
    TResult Function()? unknown,
    TResult Function()? imagePickFailed,
    TResult Function()? imageCropperFailed,
    TResult Function()? imageTooLarge,
  }) {
    return imageCropperFailed?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connection,
    TResult Function()? unknown,
    TResult Function()? imagePickFailed,
    TResult Function()? imageCropperFailed,
    TResult Function()? imageTooLarge,
    required TResult orElse(),
  }) {
    if (imageCropperFailed != null) {
      return imageCropperFailed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ConnectionFailure value) connection,
    required TResult Function(_UnknownFailure value) unknown,
    required TResult Function(_ImagePickFailedFailure value) imagePickFailed,
    required TResult Function(_ImageCropperFailedFailure value)
        imageCropperFailed,
    required TResult Function(_ImageTooLargeFailure value) imageTooLarge,
  }) {
    return imageCropperFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ConnectionFailure value)? connection,
    TResult Function(_UnknownFailure value)? unknown,
    TResult Function(_ImagePickFailedFailure value)? imagePickFailed,
    TResult Function(_ImageCropperFailedFailure value)? imageCropperFailed,
    TResult Function(_ImageTooLargeFailure value)? imageTooLarge,
  }) {
    return imageCropperFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ConnectionFailure value)? connection,
    TResult Function(_UnknownFailure value)? unknown,
    TResult Function(_ImagePickFailedFailure value)? imagePickFailed,
    TResult Function(_ImageCropperFailedFailure value)? imageCropperFailed,
    TResult Function(_ImageTooLargeFailure value)? imageTooLarge,
    required TResult orElse(),
  }) {
    if (imageCropperFailed != null) {
      return imageCropperFailed(this);
    }
    return orElse();
  }
}

abstract class _ImageCropperFailedFailure implements RegisterFailure {
  const factory _ImageCropperFailedFailure() = _$_ImageCropperFailedFailure;
}

/// @nodoc
abstract class _$ImageTooLargeFailureCopyWith<$Res> {
  factory _$ImageTooLargeFailureCopyWith(_ImageTooLargeFailure value,
          $Res Function(_ImageTooLargeFailure) then) =
      __$ImageTooLargeFailureCopyWithImpl<$Res>;
}

/// @nodoc
class __$ImageTooLargeFailureCopyWithImpl<$Res>
    extends _$RegisterFailureCopyWithImpl<$Res>
    implements _$ImageTooLargeFailureCopyWith<$Res> {
  __$ImageTooLargeFailureCopyWithImpl(
      _ImageTooLargeFailure _value, $Res Function(_ImageTooLargeFailure) _then)
      : super(_value, (v) => _then(v as _ImageTooLargeFailure));

  @override
  _ImageTooLargeFailure get _value => super._value as _ImageTooLargeFailure;
}

/// @nodoc

class _$_ImageTooLargeFailure implements _ImageTooLargeFailure {
  const _$_ImageTooLargeFailure();

  @override
  String toString() {
    return 'RegisterFailure.imageTooLarge()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _ImageTooLargeFailure);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() connection,
    required TResult Function() unknown,
    required TResult Function() imagePickFailed,
    required TResult Function() imageCropperFailed,
    required TResult Function() imageTooLarge,
  }) {
    return imageTooLarge();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? connection,
    TResult Function()? unknown,
    TResult Function()? imagePickFailed,
    TResult Function()? imageCropperFailed,
    TResult Function()? imageTooLarge,
  }) {
    return imageTooLarge?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? connection,
    TResult Function()? unknown,
    TResult Function()? imagePickFailed,
    TResult Function()? imageCropperFailed,
    TResult Function()? imageTooLarge,
    required TResult orElse(),
  }) {
    if (imageTooLarge != null) {
      return imageTooLarge();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ConnectionFailure value) connection,
    required TResult Function(_UnknownFailure value) unknown,
    required TResult Function(_ImagePickFailedFailure value) imagePickFailed,
    required TResult Function(_ImageCropperFailedFailure value)
        imageCropperFailed,
    required TResult Function(_ImageTooLargeFailure value) imageTooLarge,
  }) {
    return imageTooLarge(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_ConnectionFailure value)? connection,
    TResult Function(_UnknownFailure value)? unknown,
    TResult Function(_ImagePickFailedFailure value)? imagePickFailed,
    TResult Function(_ImageCropperFailedFailure value)? imageCropperFailed,
    TResult Function(_ImageTooLargeFailure value)? imageTooLarge,
  }) {
    return imageTooLarge?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ConnectionFailure value)? connection,
    TResult Function(_UnknownFailure value)? unknown,
    TResult Function(_ImagePickFailedFailure value)? imagePickFailed,
    TResult Function(_ImageCropperFailedFailure value)? imageCropperFailed,
    TResult Function(_ImageTooLargeFailure value)? imageTooLarge,
    required TResult orElse(),
  }) {
    if (imageTooLarge != null) {
      return imageTooLarge(this);
    }
    return orElse();
  }
}

abstract class _ImageTooLargeFailure implements RegisterFailure {
  const factory _ImageTooLargeFailure() = _$_ImageTooLargeFailure;
}
